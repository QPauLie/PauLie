Pauli DLA classification algorithm
==================================

This page explains how PauLie's Pauli DLA classification algorithm works.

Let the set of Pauli generators we want to classify be denoted as
:math:`\mathcal{P}`. We also assume that there are no Lie algebraic
dependencies in :math:`\mathcal{P}`. This means that there is no
combination of nested commutators of generators in :math:`\mathcal{P}`
that will result in another generator in :math:`\mathcal{P}`. A
generator set with no Lie algebraic dependencies is also called
*minimal*. We start by making some definitions.


**Definition 1**. *An anticommutation graph is an undirected graph
with the vertex set as* :math:`\mathcal{P}` *and the edge set as*
:math:`E=\left\{(\mathcal{P}_i,\mathcal{P}_j)\mid [\mathcal{P}_i, \mathcal{P}_j] \neq 0 \right\}`.
*In other words, two vertices are connected by an edge if they
anticommute.*


**Definition 2**. *A lightning on an anticommutation graph with
respect to a vertex* :math:`V` *denoted by* :math:`\Gamma(V)` *is a
vertex labeling on the induced subgraph of all vertices except*
:math:`V`. *Vertices adjacent to* :math:`V` *are labeled as lit and
others are labeled as unlit.*

**Definition 3**. *Given two anticommuting Pauli strings* :math:`V`
*and* :math:`W` *in* :math:`\mathcal{P}`, *a contraction of* :math:`W` *onto*
:math:`V` *replaces* :math:`V` *with* :math:`\pm \frac{1}{2}i[V,W]` *in*
:math:`\mathcal{P}`. *This leaves the Lie algebra generated by*
:math:`\mathcal{P}` *invariant.*

Notably, in terms of the anticommutation graph, this results in the
complementation of edges between :math:`V` and the neighbourhood of
:math:`W`. In terms of the lightning :math:`\Gamma(V)`, this means the
states of vertices in the neighbourhood of :math:`W` are toggled (lit
:math:`\rightarrow` unlit and vice versa).

**Definition 4**. *An undirected connected graph is called starlike
if it has a central vertex* :math:`O` *to which a non-negative number
of path graphs called legs are connected at one end. A leg* :math:`L`
*is a list of* :math:`k` *vertices denoted as*
:math:`[L_1, L_2, \ldots, L_k]` *with* :math:`L_1` *being connected to*
:math:`O`. *The length of* :math:`L` *is denoted by* :math:`|L|` *and it
is equal to* :math:`k`. *Unless mentioned otherwise, it is assumed that
legs are non-empty. Let*
:math:`S = \left\{L^{(1)}, L^{(2)}, \ldots \right\}` *be the
ordered-by-length set of legs connected to the central vertex.*

If :math:`\mathcal{P}` has a connected anticommutation graph, the paper
shows that using contractions, we can transform it into one of 4
starlike graph types. These types are called *canonical*.
Canonical graphs have at least one leg of length 1, a non-negative
number of legs of length 2, and exactly one (possibly empty) leg of
arbitrary length. Let :math:`N` be a list of vertices, each of which is
a leg of length 1. Let :math:`T` be a list of 2-tuples, where the first
element is attached to the central vertex. Let :math:`L^{\mathcal{B}}`
be the leg of arbitrary length.

There is an exception if :math:`\mathcal{P}` only has one Pauli string.
A single Pauli string generates the algebra :math:`\mathfrak{u}(1)`.

.. table:: Canonical types and associated Lie algebras for a starlike graph with :math:`n_1 + 1` :math:`\left(n_1 \geq 0\right)` legs of length :math:`1` and :math:`n_2` :math:`\left(n_2 \geq 1\right)` legs of length :math:`2`. Note that some graphs may belong to multiple canonical types, which reflects the existence of certain *exceptional isomorphisms* between Lie algebras.

   +----------------+------------------------------------------+-------------------------------------------------------------+
   | Canonical type | Structure                                | Lie algebra                                                 |
   +================+==========================================+=============================================================+
   | A              | :math:`\left|N\right| = n_1`,            | :math:`\bigoplus_{i=1}^{2^{n_1}}\mathfrak{so}(n + 3)`       |
   |                | :math:`\left|T\right| = 0`,              |                                                             |
   |                | :math:`\left|L^{\mathcal{B}}\right| = n` |                                                             |
   +----------------+------------------------------------------+-------------------------------------------------------------+
   | B1             | :math:`\left|N\right|=n_1`,              | :math:`\bigoplus_{i=1}^{2^{n_1}}\mathfrak{sp}(2^{n_2})`     |
   |                | :math:`\left|T\right| = n_2`,            |                                                             |
   |                | :math:`\left|L^{\mathcal{B}}\right|=0`   |                                                             |
   +----------------+------------------------------------------+-------------------------------------------------------------+
   | B2             | :math:`\left|N\right|=n_1`,              | :math:`\bigoplus_{i=1}^{2^{n_1}}\mathfrak{so}(2^{n_2 + 3})` |
   |                | :math:`\left|T\right| = n_2`,            |                                                             |
   |                | :math:`\left|L^{\mathcal{B}}\right|=4`   |                                                             |
   +----------------+------------------------------------------+-------------------------------------------------------------+
   | B3             | :math:`\left|N\right|=n_1`,              | :math:`\bigoplus_{i=1}^{2^{n_1}}\mathfrak{su}(2^{n_2 + 2})` |
   |                | :math:`\left|T\right| = n_2`,            |                                                             |
   |                | :math:`\left|L^{\mathcal{B}}\right|=3`   |                                                             |
   +----------------+------------------------------------------+-------------------------------------------------------------+

We construct the canonical graph by iteratively adding vertices to the
graph and using contractions at each addition to keep the graph in a
canonical form. The algorithm is divided into 4 phases. First we build
the *core* of the canonical graph. This is the central vertex with at
most 2 legs, both of length 1. Then, we take the lightning produced by
the current vertex to be added. If not all legs of length 1 have the
same lit state, we apply contractions until there is only one lit
vertex, which is a leg of length 1. Then, we transfer all lit vertices
to only the central vertex and vertices of the long leg. Finally, we
reduce this lightning until we reach a canonical type.

Non-minimal generator sets
--------------------------

We assumed in the above discussion that we start with a minimal
generator set. However, while executing the algorithm, we can keep track
of the Pauli string as we contract it. If at any point it becomes equal
to an already added Pauli string, we can skip it and determine that the
initial Pauli string was dependent. So we remove the initial Pauli
string from :math:`\mathcal{P}`.

There is one more check we must make. If we are attaching a vertex to
the center, for each vertex :math:`W` in :math:`N`, we check if
:math:`[W, V]` is equal to another already added vertex (except
:math:`W`), or if it is equal to :math:`V`. If either of these is true,
we mark :math:`V` as dependent.

Disconnected anticommutation graphs
-----------------------------------

We also assumed that :math:`\mathcal{P}` has a connected anticommutation
graph. However, if :math:`\mathcal{P}` has a disconnected
anticommutation graph, we can process each connected component
independently, and the overall Lie algebra generated by
:math:`\mathcal{P}` will be the direct sum of the individual Lie
algebras of each connected component.

Algorithm description
---------------------

We insert all the Pauli strings in :math:`\mathcal{P}` into a queue
:math:`Q`. We define the set :math:`I` of already added Pauli strings.
While :math:`Q` is non-empty, we call the functions for building the
core, converting to a single lit state, transferring the lightning, and
reducing the lightning, in that order. We also assume we have no
dependent Pauli strings and that the anticommutation graph is connected.
Now we describe the process of adding a vertex :math:`V` to the current
graph. Unless otherwise mentioned, we will refer to the lightning with
respect to :math:`V`.

.. table:: Listing of functions in the pseudocode and their descriptions

   +----------------------------------+----------------------------------+
   | Function name                    | Description                      |
   +==================================+==================================+
   | Contract(:math:`V`, :math:`U`)   | Contracts the vertex :math:`V`   |
   |                                  | with each vertex in :math:`U` in |
   |                                  | order from beginning to end.     |
   |                                  | Used as a helper function.       |
   +----------------------------------+----------------------------------+
   | Classify(:math:`\mathcal{P}`)    | Classifies the DLA formed by the |
   |                                  | Pauli strings in                 |
   |                                  | :math:`\mathcal{P}`.             |
   |                                  | :math:`\mathcal{P}` must be      |
   |                                  | minimal and have a connected     |
   |                                  | anticommutation graph.           |
   +----------------------------------+----------------------------------+
   | BuildCore(:math:`O`, :math:`N`,  | Adds :math:`V` to the *core* of  |
   | :math:`T`,                       | the canonical graph, if          |
   | :math:`L^{\mathcal{B}}`,         | applicable.                      |
   | :math:`V`)                       |                                  |
   +----------------------------------+----------------------------------+
   | LitOne(:math:`Q`, :math:`I`,     | Executed if not all legs of      |
   | :math:`O`, :math:`N`, :math:`T`, | length 1 have the same lit       |
   | :math:`L^{\mathcal{B}}`,         | state. Given a lit length 1 leg  |
   | :math:`V`)                       | of :math:`P` and an unlit leg of |
   |                                  | length :math:`Q`, it changes all |
   |                                  | vertices :math:`W` except        |
   |                                  | :math:`P` to :math:`PQW` and     |
   |                                  | attaches :math:`V` to :math:`P`. |
   |                                  | Then truncates long leg to at    |
   |                                  | most 4 vertices.                 |
   +----------------------------------+----------------------------------+
   | TransferLightning(:math:`O`,     | Executed if any vertex not on    |
   | :math:`N`, :math:`T`,            | the long leg is lit. Transfers   |
   | :math:`L^{\mathcal{B}}`,         | all lit vertices from other legs |
   | :math:`V`)                       | to the long leg and the center.  |
   +----------------------------------+----------------------------------+
   | ReduceLightning(:math:`Q`,       | Reduces the lightning            |
   | :math:`I`, :math:`O`, :math:`N`, | configuration on the long leg to |
   | :math:`T`,                       | one of two cases, then modifies  |
   | :math:`L^{\mathcal{B}}`,         | the graph to add :math:`V`.      |
   | :math:`V`)                       |                                  |
   +----------------------------------+----------------------------------+

*Connectivity check.* We first check if :math:`V` is connected to any
already added vertex. If it is, we can proceed. Otherwise, we push
:math:`V` to the back of the queue and continue.

*Step 1: Building the core.* We first check if we set the central
vertex. If not, :math:`V` is set as the central vertex. If the central
vertex was set, we check if the anticommutation graph has any legs. If
there are no legs, we can add :math:`V` as a leg of length 1. If there
is 1 leg, there are 2 cases to handle. If the existing leg and the
center are lit, we toggle the center and attach :math:`V` to it. If only
the existing leg is lit, we toggle the leg once, and then we use the
previous case. Now we have 2 legs of length 1. If there were already 2
or more legs of length 1, we skip this step.

Before proceeding to the next step, we first introduce a lemma.

**Lemma 1**. *We may remove vertices from the anticommutation graph
and operate with the modified anticommutation graph, provided we
re-add the removed vertices at a later point as regular vertices.*

The justification for this lemma is that, at each step, we construct an
alternative representation of the original algebra. If we remove some
vertices, the intermediate set no longer is representative of the
original algebra, but if we add back the vertices, it once again
represents the original algebra.

The next step requires that the long leg must not be a leg of length 1.
If the currently designated long leg has length 1, we reinterpret it as
a leg of length 1, therefore making the long leg empty. We now proceed
to the next step.

*Step 2: Converting to a single lit state.* If all legs of length 1 have
the same state, we skip this step. Otherwise, there is one leg of length
1 that is lit and one that is unlit. Let these vertices be :math:`P` and
:math:`Q`, respectively. Then, for each vertex :math:`W` which is lit,
except :math:`P`, we replace it with :math:`PQW`. This makes the vertex
unlit. This is guaranteed to be possible via Theorem 4 of the paper.
Therefore, at the end of this process, only :math:`P` is lit. Then we
can append :math:`V` to this leg. Now the graph is of type B, so if
:math:`|L^{\mathcal{B}}| > 4`, we truncate this leg to the first 4
vertices, and all further vertices are put back into the queue to be
re-added. If this step was not skipped, we can end the addition process
for :math:`V` here.

If we continue the addition process, it means that all legs of length 1
have the same state, so it does not matter which one we toggle. Their
state is collectively toggled only by :math:`O`. Therefore we can work
with :math:`N_1` WLOG. If :math:`N_1` is lit, we toggle it and :math:`O`
to make :math:`N_1` unlit. We handle a special case. If only :math:`O`
is lit, we attach to the center and exit. The succeeding steps require
the existence of a long leg. If the long leg is empty, note that the
conditions of the preceding steps guarantee the existence of a leg of
length 2 that we can reinterpret it the long leg.

*Step 3: Transferring the lightning from short legs to the long leg.* If
there is any lit vertex in a leg of length 2, then this step is
triggered. If :math:`L^{\mathcal{B}}_2` is unlit, we try to make it lit.
First, suppose there are no lit vertices in :math:`L^{\mathcal{B}}`. If
:math:`O` is lit, we toggle the sequence

.. math::

   \begin{equation}
       O, L^{\mathcal{B}}_1, N_1, O
   \end{equation}

to make :math:`L^{\mathcal{B}}_2` lit. If :math:`O` is unlit, we take a
leg :math:`\in T` with a lit vertex, toggle it to make :math:`O` lit,
and then proceed as previously. Otherwise, there exist lit vertices in
:math:`L^{\mathcal{B}}`. If :math:`L^{\mathcal{B}}_1` is lit then we
just toggle it. Otherwise, let :math:`m` be the smallest index such that
:math:`L^{\mathcal{B}}_m` is lit. We then toggle the sequence

.. math::

   \begin{equation}
       L^{\mathcal{B}}_m,L^{\mathcal{B}}_{m-1},\ldots,L^{\mathcal{B}}_3
   \end{equation}

Finally, we deal with the legs of length 2. For each leg
:math:`L \in T`, if both :math:`L_1` and :math:`L_2` are unlit, we skip
it. Otherwise, we toggle them to make both :math:`L_1` and :math:`L_2`
lit. Now, if :math:`O` is unlit, we toggle :math:`L^{\mathcal{B}}_1` to
make it lit. If :math:`L^{\mathcal{B}}_1` was unlit, we toggle
:math:`L^{\mathcal{B}}_2` to make it lit first. Then we toggle the
sequence

.. math::

   \begin{equation}
       O,L_2,L_1,N_1,O
   \end{equation}

to make both vertices in :math:`L` unlit while preserving the rest of
the lightning.

*Step 4: Reducing the lightning on the long leg and center.* If
:math:`O` is unlit at the start of this step, again let :math:`m` be the
smallest index such that :math:`L^{\mathcal{B}}_m` is lit. If :math:`O`
is unlit, such an index must exist since we made all legs in :math:`N`
and :math:`T` unlit but :math:`V` must still be connected to the graph.
We then toggle the sequence

.. math::

   \begin{equation}
       L^{\mathcal{B}}_m,L^{\mathcal{B}}_{m-1},\ldots,L^{\mathcal{B}}_1
   \end{equation}

to make :math:`O` lit. Now, the center is lit, and all other lit
vertices are on the long leg. We must first handle a special case. If
there are no lit vertices on the long leg, we can attach :math:`V` to
the center and exit. Otherwise, we iteratively reduce the number of lit
vertices on the long leg. While there are at least 2 lit vertices on the
long leg, let the index of the first one be :math:`f` and the index of
the second one be :math:`s`. Then we toggle the sequence

.. math::

   \begin{equation}
       L^{\mathcal{B}}_s,L^{\mathcal{B}}_{s-1},\ldots,L^{\mathcal{B}}_{f+1}
   \end{equation}

The result of this sequence is to move the first lit vertex by one
position away from the center. Since the length of the long leg is
finite, this means that the number of lit vertices on the long leg must
eventually reduce to 1. Note that a position with 0 lit vertices is not
possible, because the vertex we toggle last must be lit. Now, if the lit
vertex is not the first or the last vertex of the long leg, we remove
all vertices after it and put them back into the queue to be re-added.
Now we branch into 2 cases.

- *Case I: First vertex of long leg is lit.* In this case, we can toggle
  the sequence

  .. math::

     \begin{equation}
             L^{\mathcal{B}}_1,L^{\mathcal{B}}_{s-1},\ldots,L^{\mathcal{B}}_{\left|L^{\mathcal{B}}\right|}
     \end{equation}

  to attach :math:`V` to the end of the long leg. However, if the graph
  is of type B and the length of the long leg is 4, then we are not
  allowed to increase the length of the long leg any further. Therefore,
  we must attach :math:`V` elsewhere. In this situation, we instead use
  lemma (B3) from the reference to attach :math:`V` to the center. We
  toggle the sequence

  .. math::

     \begin{equation}
             O,T_{1,1},N_1,O,L^{\mathcal{B}}_1,T_{1,2},T_{1,1},O,L^{\mathcal{B}}_2,L^{\mathcal{B}}_1,L^{\mathcal{B}}_3,L^{\mathcal{B}}_2,L^{\mathcal{B}}_4,L^{\mathcal{B}}_3,N_1,O,L^{\mathcal{B}}_1,L^{\mathcal{B}}_2,T_{1,1},T_{1,2},O,L^{\mathcal{B}}_1,T_{1,1},O
     \end{equation}

  which makes only :math:`O` lit so we can attach :math:`V` to it.

- *Case II: Last vertex of long leg is lit.* In this case, we simply
  remove the last vertex of the long leg and push it back into the
  queue. Now, only the center is lit with respect to :math:`\Gamma(V)`,
  so we attach :math:`V` to the center.

Worked examples
===============

This section shows the steps of the algorithm for a graph of each
canonical type. We start by presenting the set of Pauli strings we want
to classify, and then we show the result of adding each Pauli string to
the graph. We establish the notation used in the diagrams. In each step,
we show the lightning induced by the vertex to be added. The central
vertex is marked with a crosshatch. Vertices with a non-zero commutator
with the vertex to be added are colored lit, and those with a zero
commutator are colored unlit. The vertex which we are currently toggling
is colored active. In the final step, we add the resultant vertex after
all contractions.

Graph of canonical type A
-------------------------

We classify the set
:math:`\mathcal{P}=\{IYZI,IIXX,IIYZ,IXXI,XXII,YZII\}`.

.. container:: steps

   Adding :math:`IYZI`. It is the first vertex to be added, so it is set
   as the central vertex.

   .. container:: float

   Adding :math:`IIXX`. It is added as the first leg.

   .. container:: float

   Adding :math:`IIYZ`. It is added as the second leg.

   .. container:: float

   Adding :math:`IXXI`. The legs of length 1 have unequal states, but
   there are no other vertices to modify. So we attach :math:`IXXI` to
   :math:`IIYZ` and form a leg of length 2.

   .. container:: float

   Adding :math:`XXII`. Only the center is lit, so we attach to it.

   .. container:: float

   Adding :math:`YZII`. The leg of length 2 is taken as the long leg. We
   are in *Step 4 (Case II)* of the algorithm, which means we remove
   :math:`IXXI` and attach :math:`YZII` to :math:`IYZI`.

   .. container:: float

   Re-adding :math:`IXXI`. We are in *Step 2* of the algorithm. We can
   pick :math:`P=YZII` and :math:`Q=XXII`. Only :math:`IIYZ` must be
   changed, and then we can connect :math:`IXXI` to :math:`YZII`.

   .. container:: float

The final graph is of canonical type A, and has the algebra
:math:`\mathfrak{so}(5)\oplus\mathfrak{so}(5)\oplus\mathfrak{so}(5)\oplus\mathfrak{so}(5)`.
Note that the graph may also be interpreted as being of type B1, with
the algebra
:math:`\mathfrak{sp}(2)\oplus\mathfrak{sp}(2)\oplus\mathfrak{sp}(2)\oplus\mathfrak{sp}(2)`.
This reflects an exceptional isomorphism between the two algebras.

Graph of canonical type B1
--------------------------

We classify the set
:math:`\mathcal{P}=\{IXZI,IIXZ,IIXY,IXYI,XZII,XYII\}`.

.. container:: steps

   Adding :math:`IXZI`. It is the first vertex to be added, so it is set
   as the central vertex.

   .. container:: float

   Adding :math:`IIXZ`. It is added as the first leg.

   .. container:: float

   Adding :math:`IIXY`. Both :math:`IXZI` and :math:`IIXZ` are lit, so
   we toggle the center. It is added as the second leg.

   .. container:: float

   Adding :math:`IXYI`. The legs of length 1 have unequal states so we
   are in *Step 2* of the algorithm. We pick :math:`P=IIXZ` and
   :math:`Q=IXYY`, and only the center must be modified. Then we attach
   :math:`IXYI` to :math:`IIXZ` and form a leg of length 2.

   .. container:: float

   Adding :math:`XZII`. We consider the leg of length 2 as the long leg.
   All legs of length 1 are in the same state (since there is only one
   such leg), so we make it unlit by toggling :math:`IXYY` then
   :math:`IIIX`. Since there is technically no leg of length 2, we enter
   *Step 4* of the algorithm. We reduce the configuration by (5). Then
   we remove :math:`IXYI` and attach :math:`XZIZ` to :math:`IIIX`.

   .. container:: float

   Re-adding :math:`IXYI`. The legs of length 1 have unequal states so
   we are in *Step 2* of the algorithm. We pick :math:`P=IIXZ` and
   :math:`Q=IXYY` and modify :math:`XZIZ`. Then we attach :math:`IXYI`
   to :math:`IIXZ` and form a leg of length 2.

   .. container:: float

   Adding :math:`XYII`. We are in *Step 2* of the algorithm. We can pick
   :math:`P=IXYY` and :math:`Q=XYZY`. Only :math:`IXYI` must be changed,
   and then we can connect :math:`XYII` to :math:`IXYY`.

   .. container:: float

The final graph is of canonical type B1, and has the algebra
:math:`\mathfrak{sp}(4)`.

Graph of canonical type B2
--------------------------

Graph of canonical type B3
--------------------------
