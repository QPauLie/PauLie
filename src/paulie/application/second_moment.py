"""
Module for computing the second-order twirl of an operator
over a group generated by system generators.
"""

from paulie.common.pauli_string_collection import PauliStringCollection
from paulie.common.pauli_string_linear import PauliStringLinear
from paulie.common.pauli_string_factory import get_pauli_string as p



def get_full_quadratic_basis(system_generators: PauliStringCollection) -> list['PauliStringLinear']:
    """
    Orchestrates the calculation of the full basis of quadratic symmetries {Q_kj}.
    """
    # 1. Get the linear symmetries {L_j}
    linear_symmetries = system_generators.get_commutants()

    # 2. Get the *commutator* graph components {C_k} using our new method
    connected_components = system_generators.get_commutator_graph_components()

    full_quadratic_basis = []

    # 3. For each component and symmetry, build Q_kj
    for ck_collection in connected_components:
        for lj_pauli in linear_symmetries:
            # Manually implement the formula correctly
            linear_combination_terms = []
            for s in ck_collection:
                lj_times_s = lj_pauli @ s
                tensor_prod_str = str(s) + str(lj_times_s)
                linear_combination_terms.append((1.0, tensor_prod_str))

            if linear_combination_terms:
                q_kj = PauliStringLinear(linear_combination_terms)
                full_quadratic_basis.append(q_kj)
    # 4. Return the full quadratic basis
    return full_quadratic_basis

def second_moment(
    operator_m: 'PauliStringLinear',
    system_generators: PauliStringCollection) -> 'PauliStringLinear':
    """
    Computes the second-order twirl of an operator over the group generated by the
    system_generators.

    The formula is T^(2)(M) = ∑_{j,k} [Tr(Q_jk M) / Tr(Q_jk²)] * Q_jk,
    where Q_kj are the quadratic symmetries of the system.

    Args:
        operator_m: The operator to be twirled, as a PauliStringLinear object.
        system_generators: A PauliStringCollection representing the system.

    Returns:
        The twirled operator, also as a PauliStringLinear object.
    """
    # Step 1: Get the orthogonal basis of quadratic symmetries
    q_basis = get_full_quadratic_basis(system_generators)

    # We will accumulate all the terms of the final sum here
    twirled_m_terms = []

    # Step 2: Loop over each basis vector q_kj to compute its contribution
    for q_kj in q_basis:
        # Step 3: Calculate the coefficient numerator: Tr(q_kj * operator_m)
        # Note: This requires PauliStringLinear to support the @ product and a .trace() method.
        prod = q_kj @ operator_m
        trace_numerator = prod.trace()

        # If the trace is zero, this basis vector has no overlap with operator_m
        if abs(trace_numerator) < 1e-12:
            continue

        # Step 4: Calculate the coefficient denominator: Tr(q_kj²)
        # From the orthogonality proof, Tr(q_kj²) = |C_k| * d_Q, where |C_k| is
        # the number of Pauli strings in the sum for q_kj.
        num_terms = len(q_kj) # Assumes len() is defined for PauliStringLinear
        num_qubits_q = q_kj.get_size()
        trace_denominator = num_terms * (2**num_qubits_q)

        # Step 5: Calculate the final coefficient for this basis element
        coeff = trace_numerator / trace_denominator

        # Step 6: Add the scaled basis vector q_kj * coeff to our final sum
        # Note: This requires PauliStringLinear to support scalar multiplication.
        scaled_q = q_kj * coeff
        twirled_m_terms.extend(scaled_q)

    # Step 7: Create and simplify the final PauliStringLinear object
    if not twirled_m_terms:
        # If the result is zero, return a zero operator of the correct size
        final_size = operator_m.get_size()
        return p([(0.0, 'I' * final_size)])

    # Create the final object and simplify (combine terms with the same Pauli string)
    final_operator = p(twirled_m_terms)
    return final_operator.simplify()
