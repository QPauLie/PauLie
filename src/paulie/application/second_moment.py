"""
Module for computing the second-order twirl of an operator
over a group generated by system generators, based on the theory
in arXiv:2502.16404.
"""
import numpy as np
from paulie.common.pauli_string_collection import PauliStringCollection
from paulie.common.pauli_string_linear import PauliStringLinear

def get_full_quadratic_basis(system_generators: PauliStringCollection) -> list['PauliStringLinear']:
    """
    Implements Eq. (8) from arXiv:2502.16404 to generate a full,
    ORTHOGONAL (but not normalized) basis of quadratic symmetries {Q_kj}.
    """
    # Step 1: Find the linear symmetries L_j
    linear_symmetries = system_generators.get_commutants()

    # Step 2: Find the connected components C_k of the commutator graph
    connected_components = system_generators.get_graph_components(graph_type='commutator')

    full_quadratic_basis = []
    for ck_collection in connected_components:
        # Convert component C_k into a PauliStringLinear object C_k = sum(S)
        ck_linear = PauliStringLinear([(1.0, str(S)) for S in ck_collection])

        for lj_pauli in linear_symmetries:
            # Call the quadratic method to compute Q_kj = sum[S in C_k] S tensor (Lj * S)
            q_kj = ck_linear.quadratic(lj_pauli)
            if not q_kj.is_zero():
                full_quadratic_basis.append(q_kj)

    return full_quadratic_basis


def get_normalized_quadratic_basis(system_generators: PauliStringCollection) -> list['PauliStringLinear']:
    """
    Calculates the full, ORTHONORMAL basis of quadratic symmetries {Q_kj}.
    Each returned vector is scaled to have a norm of 1.
    """
    orthogonal_basis = get_full_quadratic_basis(system_generators)
    
    normalized_basis = []
    for q_vector in orthogonal_basis:
        # The squared norm is Tr(Q†Q)
        squared_norm_trace = (q_vector.H @ q_vector).trace()

        if squared_norm_trace.real > 1e-12:
            norm = np.sqrt(squared_norm_trace.real)
            # The paper's convention uses Hilbert-Schmidt norm. To match the
            # expectation of the user, we'll normalize to a simple norm of 1.
            # Tr(Q_norm† * Q_norm) = 1.
            # A common normalization is to make Tr(Q†Q) = d = 2^n.
            # We will just normalize the coefficient vector to 1.
            normalized_basis.append(q_vector * (1.0 / q_vector.norm()))

    return normalized_basis


def second_moment(
    operator_m: PauliStringLinear, system_generators: PauliStringCollection
) -> PauliStringLinear:
    """
    Computes the second-order twirl of an operator M by projecting it onto the
    subspace of quadratic symmetries, as per arXiv:2502.16404.
    The formula is: T(M) =  ∑_{k,j} [Tr(Q_kj† M) / Tr(Q_kj† Q_kj)] * Q_kj
    """
    q_basis = get_full_quadratic_basis(system_generators)
    twirl_result = PauliStringLinear([(0.0, 'I' * operator_m.get_size())])

    for q_kj in q_basis:
        # Numerator: Tr(Q_kj† M)
        trace_numerator = (q_kj.H @ operator_m).trace()
        if abs(trace_numerator) < 1e-12:
            continue

        # Denominator: Tr(Q_kj† Q_kj), the squared norm.
        trace_denominator = (q_kj.H @ q_kj).trace()
        if abs(trace_denominator) < 1e-12:
            continue
        
        coeff = trace_numerator / trace_denominator
        projection = q_kj * coeff
        twirl_result += projection
        
    return twirl_result.simplify()