from paulie.common.pauli_string_collection import PauliStringCollection
from paulie.common.pauli_string_linear import PauliStringLinear
from paulie.common.pauli_string_factory import get_pauli_string as p

def second_moment(M: 'PauliStringLinear', system_generators: PauliStringCollection) -> 'PauliStringLinear':
    """
    Computes the second-order twirl of an operator M over the group G
    generated by the system_generators.

    The formula is T^(2)(M) = ∑_{j,k} [Tr(Q_jk M) / Tr(Q_jk²)] * Q_jk,
    where Q_kj are the quadratic symmetries of the system.

    Args:
        M: The operator to be twirled, as a PauliStringLinear object.
        system_generators: A PauliStringCollection representing the system.

    Returns:
        The twirled operator, also as a PauliStringLinear object.
    """
    
    # Step 1: Get the orthogonal basis of quadratic symmetries
    Q_basis = system_generators.get_quadratic_symmetries()
    
    # We will accumulate all the terms of the final sum here
    twirled_M_terms = []

    # Step 2: Loop over each basis vector Q_kj to compute its contribution
    for Q_kj in Q_basis:
        # Step 3: Calculate the coefficient numerator: Tr(Q_kj * M)
        # Note: This requires PauliStringLinear to support the @ product and a .trace() method.
        prod = Q_kj @ M
        trace_numerator = prod.trace()

        # If the trace is zero, this basis vector has no overlap with M
        if trace_numerator == 0:
            continue

        # Step 4: Calculate the coefficient denominator: Tr(Q_kj²)
        # From the orthogonality proof, Tr(Q_kj²) = |C_k| * d_Q, where |C_k| is
        # the number of Pauli strings in the sum for Q_kj.
        num_terms = len(Q_kj) # Assumes len() is defined for PauliStringLinear
        num_qubits_Q = Q_kj.get_size()
        trace_denominator = num_terms * (2**num_qubits_Q)

        # Step 5: Calculate the final coefficient for this basis element
        coeff = trace_numerator / trace_denominator
        
        # Step 6: Add the scaled basis vector Q_kj * coeff to our final sum
        # Note: This requires PauliStringLinear to support scalar multiplication.
        scaled_Q = Q_kj * coeff
        twirled_M_terms.extend(scaled_Q)

    # Step 7: Create and simplify the final PauliStringLinear object
    if not twirled_M_terms:
        # If the result is zero, return a zero operator of the correct size
        final_size = M.get_size()
        return p([(0.0, 'I' * final_size)])

    # Create the final object and simplify (combine terms with the same Pauli string)
    final_operator = p(twirled_M_terms)
    return final_operator.simplify()