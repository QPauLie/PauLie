"""
Unit tests for the second_moment application and related functions.
"""
import pytest

from paulie.common.pauli_string_factory import get_pauli_string as p
from paulie.application.second_moment import second_moment, get_full_quadratic_basis
from paulie.common.pauli_string_linear import PauliStringLinear

# We group the tests into a class for organization, but use pytest-style asserts.
class TestSecondMoment:
    """
    Test suite for the second_moment function.
    """

    def test_reproduces_supplemental_example_2(self):
        """
        Tests that the implementation correctly reproduces the known quadratic
        symmetries for the system generated by {"X"}. This is a critical
        test that validates the core logic and phase calculations.
        """
        system = p(["X"])
        q_basis = get_full_quadratic_basis(system)

        # This is the expected vector from the paper, verifying i*YZ - i*ZY
        expected_q_vector = p([(1j, "YZ"), (-1j, "ZY")])

        # Check if a vector mathematically equal to the expected one exists in the basis.
        # This relies on the robust __eq__ method in PauliStringLinear.
        assert expected_q_vector in q_basis, \
            "The basis did not contain the correct i*YZ - i*ZY vector."

    def test_projection_of_symmetry_is_identity(self):
        """
        Tests that twirling a quadratic symmetry returns that same symmetry.
        This is a crucial test of the `second_moment` projection logic.
        """
        system = p(["Z"])
        q_basis = get_full_quadratic_basis(system)

        # Find the specific Q_kj vector that corresponds to IZ
        operator_m = next((q for q in q_basis if str(q) == "IZ"), None)
        assert operator_m is not None, "Could not find the IZ symmetry vector in the basis."

        # Twirling a basis vector must return that exact same vector.
        twirled_m = second_moment(operator_m, system)

        assert twirled_m == operator_m

    def test_projection_to_zero(self):
        """
        Tests that an operator with no overlap with the quadratic symmetries
        is correctly projected to the zero operator.
        """
        system = p(["Z"])
        # XI is orthogonal to all quadratic symmetries of the Z group
        operator_m = p([(1.0, "XI")])
        twirled_m = second_moment(operator_m, system)

        # is_zero() is a helper method we implemented
        assert twirled_m.is_zero(), f"Expected a zero operator, but got {twirled_m}"

    def test_gksmail_demonstration_case(self):
        """
        Tests the quadratic symmetry generation against the specific
        example for the a_5 system (n=2).
        This test verifies that the final refactored implementation correctly
        computes the full basis by iterating through the components and
        linear symmetries.
        """
        # 1. Recreate the list of connected components {C_k} for the a_5 system.
        #    Each component is a PauliStringCollection.
        components_ck = [
            p(["II"]), p(["XY"]), p(["ZX"]), p(["YZ"]),
            p(["ZI", "XZ", "IX", "YY"]),  # The 4-element component
            p(["XI", "ZZ"]),
            p(["IY", "YX"]),
            p(["YI", "ZY"]),
            p(["IZ", "XX"])
        ]
        assert len(components_ck) == 9, "Should be 9 connected components for a_5"

        # 2. Recreate the list of linear symmetries {L_j} for the a_5 system.
        linear_symmetries_lj = p(["II", "XY", "ZX", "YZ"])
        assert len(linear_symmetries_lj), 4 #"Should be 4 linear symmetries for a_5"

        # 3. Use our final, refactored logic to compute the full basis.
        #    This mimics the logic from the `get_full_quadratic_basis` orchestrator we deleted.
        full_quadratic_basis = []

        # For each component Ck in our list...
        for ck in components_ck:
            # ...compute its associated symmetries by passing the linear symmetries as an argument.
            # This directly calls the final version of our method.
            q_for_this_component = ck.get_quadratic_symmetries(linear_symmetries_lj)
            full_quadratic_basis.extend(q_for_this_component)

        # 4. Assert the final result is correct.
        #    The total number of Q_kj should be (number of components) * (number of symmetries).
        expected_q_count = len(components_ck) * len(linear_symmetries_lj)  # 9 * 4 = 36

        assert len(full_quadratic_basis) == expected_q_count
        #"The total number of generated quadratic symmetries is incorrect."

        # A deeper check to ensure all generated objects have the correct type.
        for q in full_quadratic_basis:
            assert isinstance(q, PauliStringLinear)
            #"All generated symmetries should be PauliStringLinear objects."


generator_list = [
    ["I"], ["X"], ["Y"], ["Z"],
    ["ZI", "IZ", "XX"], # a5 Lie algebra
    ["XI", "IX", "YY"]  # a5 Lie algebra
]

@pytest.mark.parametrize("generators", generator_list)
def test_twirl_of_basis_vector_is_idempotent(generators: list[str]):
    """
    Tests that the twirl (projection) of a quadratic symmetry basis vector
    returns that same vector. This is a fundamental property of a projection:
    P(v) = v, for any v in the target subspace.
    """
    system = p(generators)
    quad_symmetries = get_full_quadratic_basis(system)

    # The twirl should be the identity operator for any vector
    # already in the symmetry subspace.
    for quadsym in quad_symmetries:
        # Twirl the basis vector.
        twirled_q = second_moment(quadsym, system)

        # The result of the twirl should be the original symmetry operator.
        # We use a robust equality check that handles floating point errors.
        assert twirled_q == quadsym, \
            f"Twirl of basis vector failed. Expected {quadsym}, got {twirled_q}"
