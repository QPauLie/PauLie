"""
Module for computing the second-order twirl of an operator
over a group generated by system generators.
"""

from paulie.common.pauli_string_collection import PauliStringCollection
from paulie.common.pauli_string_linear import PauliStringLinear



def get_full_quadratic_basis(system_generators: PauliStringCollection) -> list['PauliStringLinear']:
    """
    Orchestrates the calculation of the full basis of quadratic symmetries {Q_kj}.
    """
    # 1. Get the linear symmetries {L_j}
    linear_symmetries = system_generators.get_commutants()

    # 2. Get the *commutator* graph components {C_k} using our new method
    connected_components = system_generators.get_graph_components(graph_type='commutator')

    full_quadratic_basis = []
    for ck_collection in connected_components:
        # Convert the component into a PauliStringLinear object
        ck_linear = PauliStringLinear([(1.0, str(S)) for S in ck_collection])

        for lj_pauli in linear_symmetries:
            # Call the now-corrected quadratic method
            q_kj = ck_linear.quadratic(lj_pauli)
            full_quadratic_basis.append(q_kj)

    return full_quadratic_basis

def second_moment(
    operator_m: 'PauliStringLinear',
    system_generators: PauliStringCollection) -> 'PauliStringLinear':
    """
    Computes the second-order twirl of an operator over the group generated by the
    system_generators.

    The formula is T^(2)(M) = ∑_{j,k} [Tr(Q_jk M) / Tr(Q_jk²)] * Q_jk,
    where Q_kj are the quadratic symmetries of the system.

    Args:
        operator_m: The operator to be twirled, as a PauliStringLinear object.
        system_generators: A PauliStringCollection representing the system.

    Returns:
        The twirled operator, also as a PauliStringLinear object.
    """
    # Step 1: Get the orthogonal basis of quadratic symmetries
    q_basis = get_full_quadratic_basis(system_generators)

    # We will accumulate all the terms of the final sum here
    final_size = operator_m.get_size()
    twirl_result = PauliStringLinear([(0.0, 'I' * final_size)])

    # Step 2: Loop over each basis vector q_kj to compute its contribution
    for q_kj in q_basis:
        # Step 3: Calculate the coefficient numerator: Tr(q_kj * operator_m)
        # Note: This requires PauliStringLinear to support the @ product and a .trace() method.
        prod = q_kj @ operator_m
        trace_numerator = prod.trace()

        # If the trace is zero, this basis vector has no overlap with operator_m
        if abs(trace_numerator) < 1e-12:
            continue

        # Step 4: Calculate the coefficient denominator: Tr(q_kj²)
        # From the orthogonality proof, Tr(q_kj²) = |C_k| * d_Q, where |C_k| is
        # the number of Pauli strings in the sum for q_kj.
        num_terms = len(q_kj.combinations)
        num_qubits_q = q_kj.get_size()
        trace_denominator = num_terms * (2**num_qubits_q)

        # Step 5: Calculate the final coefficient for this basis element
        coeff = trace_numerator / trace_denominator
        projection = q_kj * coeff

        # Use the `+=` operator, which calls the __iadd__ or __add__ method
        # of the PauliStringLinear class to perform a correct mathematical sum.
        twirl_result += projection

    # The final simplification is handled inside the loop's addition,
    # but an extra simplify here ensures a canonical form.
    return twirl_result.simplify()
