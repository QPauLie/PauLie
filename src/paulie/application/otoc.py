"""
    Compute the average out-of-time-order correlator between two Pauli strings.
"""
from collections import deque
from paulie.common.pauli_string_collection import PauliStringCollection
from paulie.common.pauli_string_bitarray import PauliString

def average_otoc(generators: PauliStringCollection, v: PauliString, w: PauliString) -> float:
    r"""
    Finds the Haar averaged out-of-time-order correlator :math:`F` between two Pauli strings
    :math:`V` and :math:`W`.

    We write it as

    .. math::

        \mathbb{E}_U[F(W, U^\dagger V U)] = \frac{\mathbb{E}_U[\mathrm{tr}
        (W U^\dagger V U W U^\dagger V U)]}{d}

    where :math:`U` is sampled according to the Haar measure on the Lie group corresponding to the
    DLA generated by `generators` and :math:`d` is the dimension of the Hilbert space.

    We can compute this via the commutator graph as

    .. math::

        F=1 - 2\frac{|\{W, P\} = 0 : P\text{ in connected component of }V|}
        {|\text{connected component of }V|}

    (arXiV:2502.16404)

    Args:
        generators (PauliStringCollection): Generating set of the Pauli string DLA.
        v (PauliString): Pauli string :math:`V`
        w (PauliString): Pauli string :math:`W`

    Returns:
        float: Haar averaged out-of-time-order correlator :math:`F` between two Pauli strings
        :math:`V` and :math:`W`.
    """
    # Number of elements in connected component of V that anti-commute with W
    anti_commute_count = 0
    # Run BFS algorithm to discover connected component of V
    v_connected_component_size = 0
    visited = set()
    queue = deque([v])
    while queue:
        t = queue.popleft()
        if t in visited:
            continue
        visited.add(t)
        if not w | t:
            anti_commute_count += 1
        v_connected_component_size += 1
        for g in generators:
            comm = t ^ g
            if comm and comm not in visited:
                queue.append(comm)
    return 1 - 2 * anti_commute_count / v_connected_component_size
