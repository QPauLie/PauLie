"""
Unit tests for the second_moment function in paulie.application.second_moment.
"""
import unittest

from paulie.common.pauli_string_factory import get_pauli_string as p
from paulie.common.pauli_string_linear import PauliStringLinear

from paulie.application.second_moment import second_moment
from paulie.application.second_moment import get_full_quadratic_basis


class TestSecondMoment(unittest.TestCase):
    """
    Unit tests for the second_moment function.
    These tests use the factory function `p()` for object creation
    to align with the library's design philosophy.
    """
    def test_projection_to_zero(self):
        """
        Tests that an operator with no overlap with the quadratic symmetries
        is correctly projected to the zero operator.
        """
        system = p(["Z"])
        operator_m = p([(1.0, "XI")]) # Changed to use p()
        twirled_m = second_moment(operator_m, system)
        self.assertTrue(twirled_m.is_zero(), f"Expected a zero operator, but got {twirled_m}")

    def test_projection_of_symmetry_is_identity_mapping(self):
        """
        Tests that twirling a quadratic symmetry basis vector returns the
        same vector, confirming the projection logic.
        """
        system = p(["Z"])
        operator_m = p([(1.0, "IZ")]) # Changed to use p()
        twirled_m = second_moment(operator_m, system)
        self.assertEqual(twirled_m, operator_m, f"Expected {operator_m}, "+
                         "but twirling returned {twirled_m}")

        # Test a more complex symmetry
        operator_m_complex = p([(1.0, "XX"), (1.0, "YY")]) # Changed to use p()
        twirled_m_complex = second_moment(operator_m_complex, system)
        self.assertEqual(twirled_m_complex, operator_m_complex)

    def test_gksmail_demonstration_case(self):
        """
        Tests the quadratic symmetry generation against the specific
        example for the a_5 system (n=2).

        This test verifies that the final refactored implementation correctly
        computes the full basis by iterating through the components and
        linear symmetries.
        """
        # 1. Recreate the list of connected components {C_k} for the a_5 system.
        #    Each component is a PauliStringCollection.
        components_ck = [
            p(["II"]), p(["XY"]), p(["ZX"]), p(["YZ"]),
            p(["ZI", "XZ", "IX", "YY"]),  # The 4-element component
            p(["XI", "ZZ"]),
            p(["IY", "YX"]),
            p(["YI", "ZY"]),
            p(["IZ", "XX"])
        ]
        self.assertEqual(len(components_ck), 9, "Should be 9 connected components for a_5")

        # 2. Recreate the list of linear symmetries {L_j} for the a_5 system.
        linear_symmetries_lj = p(["II", "XY", "ZX", "YZ"])
        self.assertEqual(len(linear_symmetries_lj), 4, "Should be 4 linear symmetries for a_5")

        # 3. Use our final, refactored logic to compute the full basis.
        #    This mimics the logic from the `get_full_quadratic_basis` orchestrator we deleted.
        full_quadratic_basis = []

        # For each component Ck in our list...
        for ck in components_ck:
            # ...compute its associated symmetries by passing the linear symmetries as an argument.
            # This directly calls the final version of our method.
            q_for_this_component = ck.get_quadratic_symmetries(linear_symmetries_lj)
            full_quadratic_basis.extend(q_for_this_component)

        # 4. Assert the final result is correct.
        #    The total number of Q_kj should be (number of components) * (number of symmetries).
        expected_q_count = len(components_ck) * len(linear_symmetries_lj)  # 9 * 4 = 36

        self.assertEqual(len(full_quadratic_basis), expected_q_count,
                         "The total number of generated quadratic symmetries is incorrect.")

        # A deeper check to ensure all generated objects have the correct type.
        for q in full_quadratic_basis:
            self.assertIsInstance(q, PauliStringLinear,
                                  "All generated symmetries should be PauliStringLinear objects.")

    def test_supplemental_example_2_phase_is_correct(self):
        """
        Tests that the quadratic symmetry generation correctly handles the phase
        of the Pauli product, reproducing the result from Supplemental Example 2
        of the reference paper (for the system generated by {"X"}).
        """
        # 1. Define the system from the example.
        system = p(["X"])

        # 2. Compute the full basis of quadratic symmetries.
        q_basis = get_full_quadratic_basis(system)

        # 3. Define the expected result from the paper.
        #    This is the Q_kj for L_j=X and C_k={Y,Z}, which is i*YZ - i*ZY.
        expected_q_vector = p([(1j, "YZ"), (-1j, "ZY")])

        # 4. Check if our computed basis contains the expected vector.
        #    We use `assertIn` which relies on the `__eq__` method we wrote
        #    for PauliStringLinear to correctly compare for mathematical equality.
        self.assertIn(expected_q_vector, q_basis,
                      "The basis did not contain the correct i*YZ - i*ZY vector.")

        # We can also do a more direct check. For this system, the linear symmetries
        # are {I, X} and the components are {I}, {X}, {Y, Z}.
        # The Q_kj corresponding to L_j=X and C_k={Y,Z} should be the one.
        # Let's find it.
        found_it = False
        for q_vector in q_basis:
            # Check if this vector has the terms YZ and ZY
            pauli_strings_in_vector = {str(pauli) for _, pauli in q_vector}
            if "YZ" in pauli_strings_in_vector and "ZY" in pauli_strings_in_vector:
                # We found the vector, now assert it's exactly correct
                self.assertEqual(q_vector, expected_q_vector)
                found_it = True
                break

        self.assertTrue(found_it, "Could not find the specific {Y,Z} component symmetry.")
        
    
    def test_reproduces_supplemental_example_2(self):
        """
        Tests that the implementation correctly reproduces the known quadratic
        symmetries for the system generated by {"X"}, validating the fix in
        the .quadratic() method.
        """
        system = p(["X"])
        q_basis = get_full_quadratic_basis(system)
        expected_q_vector = p([(1j, "YZ"), (-1j, "ZY")])
        self.assertIn(expected_q_vector, q_basis)

    def test_projection_of_symmetry_is_identity(self):
        """
        Tests that twirling a quadratic symmetry returns a result
        proportional to the original symmetry.
        """
        system = p(["Z"])
        q_basis = get_full_quadratic_basis(system)

        # Find a simple, single-term symmetry vector in the basis
        operator_m = next((q for q in q_basis if "IZ" in str(q) and len(q.combinations) == 1), None)
        self.assertIsNotNone(operator_m, "Could not find the IZ symmetry vector in the basis.")

        twirled_m = second_moment(operator_m, system)

        # Check for proportionality by comparing the normalized vectors.
        # This is a robust way to check for mathematical equivalence up to a scalar factor.
        norm_twirled = twirled_m.norm()
        norm_original = operator_m.norm()

        # Avoid division by zero if either operator is zero
        if abs(norm_twirled) < 1e-9 or abs(norm_original) < 1e-9:
            self.assertAlmostEqual(norm_twirled, norm_original)
        else:
            # Normalize both vectors by dividing by their norm
            twirled_m_normalized = twirled_m * (1/norm_twirled)
            operator_m_normalized = operator_m * (1/norm_original)

            # The normalized vectors should be equal.
            self.assertEqual(twirled_m_normalized, operator_m_normalized)
