import unittest
from paulie.common.pauli_string_factory import get_pauli_string as p
from paulie.application.second_moment import second_moment

class TestSecondMoment(unittest.TestCase):

    def test_simple_system_twirl(self):
        """
        Tests the second moment calculation for a simple 1-qubit system.
        """
        # System generators: a single Pauli Z
        system = p(["Z"])

        # The operator to twirl: X âŠ— I
        M = p([(1.0, "XI")])

        # --- Verification Step ---
        # Get the basis of quadratic symmetries
        quadratic_symmetries = system.get_quadratic_symmetries()

        # Let's verify the number of symmetries generated.
        # For a system generated by {"Z"} on n=1 qubit:
        # 1. Linear Symmetries L_j = {I, Z} (count = 2)
        # 2. Commutator Graph Components C_k = {{I}, {Z}, {X, Y}} (count = 3)
        # Total Q_kj = 2 * 3 = 6.
        # The previous assertion of 4 was incorrect.
        self.assertEqual(len(quadratic_symmetries), 6)

        # --- Main Test ---
        # Now, compute the twirl
        twirled_M = second_moment(M, system)
        
        # The physical result should still be zero, because the operator "XI"
        # has no overlap with the quadratic symmetries of this system.
        
        # A robust check is to assert that the resulting PauliStringLinear is zero.
        # We assume the class has a helper method `is_zero()` which might check
        # if the norm is close to zero or if the internal list is empty after simplification.
        self.assertTrue(twirled_M.is_zero(), 
                        f"Expected a zero operator, but got {twirled_M}")