import numpy as np
from _typeshed import Incomplete
from paulie.common.pauli_string_bitarray import PauliString
from typing import Generator, Self

class PauliStringLinearException(Exception): ...

class PauliStringLinear(PauliString): # type: ignore[misc]
    nextpos: int
    combinations: Incomplete
    def __init__(self, combinations: list[tuple[complex, str | PauliString]]) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Self: ...
    def __next__(self) -> tuple[complex, PauliString]: ...
    def __setitem__(self, position: int, combination: tuple[complex, PauliString]) -> None: ...
    def __getitem__(self, position: int) -> tuple[complex, PauliString]: ...
    def __copy__(self) -> Self: ...
    def copy(self) -> Self: ...
    def __add__(self, other: object) -> PauliStringLinear: ...
    def __iadd__(self, other: object) -> Self: ...
    def __or__(self, other: object) -> bool: ...
    def __xor__(self, other: object) -> bool: ...
    def __matmul__(self, other: object) -> PauliString | PauliStringLinear: ...
    def __rmatmul__(self, other: object) -> PauliStringLinear: ...
    def __rmul__(self, scalar: complex) -> Self: ...
    def __mul__(self, scalar: complex) -> PauliString | PauliStringLinear: ...
    @property
    def h(self) -> Self: ...
    def multiply(self, other: PauliString | Self) -> Self: ...
    def commutes_with(self, other: PauliString) -> bool: ...
    def get_substring(self, start: int, length: int = 1) -> Self: ...
    def set_substring(self, start: int, pauli_string: str | Self) -> None: ...
    def is_identity(self) -> bool: ...
    def tensor(self, other: Self) -> Self: ...
    def kron(self, other: PauliString) -> PauliStringLinear: ...
    def rkron(self, other: PauliString) -> PauliStringLinear: ...
    def quadratic(self, basis: Self) -> Self: ...
    def adjoint_map(self, other: object) -> Self: ...
    def inc(self) -> None: ...
    def expand(self, n: int) -> Self: ...
    def gen_all_pauli_strings(self) -> Generator[list[Self], None, None]: ...
    def get_commutants(self, generators: list[Self] | None = None) -> list[Self]: ...
    def get_anti_commutants(self, generators: list[Self] | None = None) -> list[Self]: ...
    def get_nested(self, generators: list[Self] | None = None) -> list[tuple[Self, Self]]: ...
    def get_matrix(self) -> np.ndarray: ...
    def exponential(self) -> np.ndarray: ...
    def simplify(self) -> PauliString | PauliStringLinear: ...
    def trace(self) -> complex: ...
    def get_size(self) -> int: ...
    def is_zero(self) -> bool: ...
    def norm(self) -> float: ...
