"""
Unit tests for the second_moment application and related functions.
"""
import pytest

from paulie.common.pauli_string_factory import get_pauli_string as p
from paulie.application.second_moment import second_moment

# We group the tests into a class for organization, but use pytest-style asserts.
class TestSecondMoment:
    """
    Test suite for the second_moment function.
    """

    def test_reproduces_supplemental_example_2(self):
        """
        Tests that the implementation correctly reproduces the known quadratic
        symmetries for the system generated by {"X"}. This is a critical
        test that validates the core logic and phase calculations.
        """
        system = p(["X"])
        q_basis = system.get_full_quadratic_basis()

        # This is the expected vector from the paper, verifying i*YZ - i*ZY
        expected_q_vector = p([(1j, "YZ"), (-1j, "ZY")])

        # Check if a vector mathematically equal to the expected one exists in the basis.
        # This relies on the robust __eq__ method in PauliStringLinear.
        assert expected_q_vector in q_basis, \
            "The basis did not contain the correct i*YZ - i*ZY vector."

    def test_projection_of_symmetry_is_identity(self):
        """
        Tests that twirling a quadratic symmetry returns that same symmetry.
        This is a crucial test of the `second_moment` projection logic.
        """
        system = p(["Z"])
        q_basis = system.get_full_quadratic_basis()

        # Find the specific Q_kj vector that corresponds to IZ
        operator_m = next((q for q in q_basis if str(q) == "IZ"), None)
        assert operator_m is not None, "Could not find the IZ symmetry vector in the basis."

        # Twirling a basis vector must return that exact same vector.
        twirled_m = second_moment(operator_m, system)

        assert twirled_m == operator_m

    def test_projection_to_zero(self):
        """
        Tests that an operator with no overlap with the quadratic symmetries
        is correctly projected to the zero operator.
        """
        system = p(["Z"])
        # XI is orthogonal to all quadratic symmetries of the Z group
        operator_m = p([(1.0, "XI")])
        twirled_m = second_moment(operator_m, system)

        # is_zero() is a helper method we implemented
        assert twirled_m.is_zero(), f"Expected a zero operator, but got {twirled_m}"

    def test_gksmail_demonstration_case(self):
        """
        Tests the quadratic symmetry generation against the specific a_5 system.
        This test now correctly calls the low-level component-specific method.
        """
        # Step 1: Define the connected components {C_k}
        components_ck = [
            p(["II"]), p(["XY"]), p(["ZX"]), p(["YZ"]),
            p(["ZI", "XZ", "IX", "YY"]),
            p(["XI", "ZZ"]), p(["IY", "YX"]),
            p(["YI", "ZY"]), p(["IZ", "XX"])
        ]

        # Step 2: Define the linear symmetries {L_j}
        linear_symmetries_lj = p(["II", "XY", "ZX", "YZ"])

        # Step 3: Loop through components and call the HELPER method for each.
        full_quadratic_basis = []
        for ck in components_ck:
            # Call the private helper, passing the pre-computed linear symmetries
            q_for_this_component = ck.get_symmetries_for_component(linear_symmetries_lj)
            full_quadratic_basis.extend(q_for_this_component)

        # Step 4: Assert the final count is correct
        expected_q_count = len(components_ck) * len(linear_symmetries_lj) # 9 * 4 = 36
        assert len(full_quadratic_basis) == expected_q_count


generator_list = [
    ["I"], ["X"], ["Y"], ["Z"],
    ["ZI", "IZ", "XX"], # a5 Lie algebra
    ["XI", "IX", "YY"]  # a5 Lie algebra
]

@pytest.mark.parametrize("generators", generator_list)
def test_twirl_of_basis_vector_is_idempotent(generators: list[str]):
    """
    Tests that the twirl (projection) of a quadratic symmetry basis vector
    returns that same vector. This is a fundamental property of a projection:
    P(v) = v, for any v in the target subspace.
    """
    system = p(generators)
    quad_symmetries = system.get_full_quadratic_basis(system)

    # The twirl should be the identity operator for any vector
    # already in the symmetry subspace.
    for quadsym in quad_symmetries:
        # Twirl the basis vector.
        twirled_q = second_moment(quadsym, system)

        # The result of the twirl should be the original symmetry operator.
        # We use a robust equality check that handles floating point errors.
        assert twirled_q == quadsym, \
            f"Twirl of basis vector failed. Expected {quadsym}, got {twirled_q}"
